import torch

import matplotlib.pyplot as plt
import numpy as np

from models.vae import VAE

def plotGANGeneratorSamples(results, step: int=1):
    genSamples = results["generator_samples"]
    epochs = len(genSamples)
    imgsPerSample = genSamples[0].size(0)

    assert epochs >= step, f"No epochs matched the step={step}. try a smaller step"

    selectedEpochs = [i for i in range(step, epochs+1, step)]
    selectedSamples = [genSamples[i-1] for i in selectedEpochs]
    numCols = len(selectedEpochs)

    # Create a series of subplots
    fig, axs = plt.subplots(nrows=imgsPerSample,
                            ncols=numCols,
                            figsize=(epochs, imgsPerSample)
                            )
    
    for col, genSample in enumerate(selectedSamples):
        genSample = genSample.detach().cpu()

        # permute samples from BCHW -> BHWC (make matplotlib friendly)
        permutedSample = genSample.permute(0,2,3,1)
        for sampleIdx, img in enumerate(permutedSample):
            img = img.numpy()
            img = (img + 1) / 2

            ax = axs[sampleIdx, col]
            ax.imshow(img.squeeze(), cmap="gray" if img.shape[-1]==1 else None)
            ax.axis("off")

    bigAx = fig.add_subplot(111, frameon=False)
    bigAx.set_xticks(np.arange(numCols))
    bigAx.set_yticks(np.arange(imgsPerSample))

    bigAx.set_xticklabels([f"{e}" for e in selectedEpochs])
    bigAx.set_yticklabels([f"{i}" for i in range(imgsPerSample)])

    bigAx.set_xlabel("Epoch")
    bigAx.set_ylabel("Latent Sample")
    bigAx.tick_params(labelcolor='black', top=False, bottom=False, left=False, right=False)

    fig.suptitle(f"Images Generated by GAN", fontsize=16)
    
    plt.tight_layout(rect=(0, 0, 1, 0.95))
    plt.show()

def plotVAEDecoderSamples(results, step: int=1, title: str=""):
    genSamples = results["decoder_samples"]
    epochs = len(genSamples)
    imgsPerSample = genSamples[0].size(0)

    assert epochs >= step, f"No epochs matched the step={step}. try a smaller step"

    selectedEpochs = [i for i in range(step, epochs+1, step)]
    selectedSamples = [genSamples[i-1] for i in selectedEpochs]
    numCols = len(selectedEpochs)

    # Create a series of subplots
    fig, axs = plt.subplots(nrows=imgsPerSample,
                            ncols=numCols,
                            figsize=(epochs, imgsPerSample)
                            )
    
    for col, genSample in enumerate(selectedSamples):
        genSample = genSample.detach().cpu()

        # permute samples from BCHW -> BHWC (make matplotlib friendly)
        permutedSample = genSample.permute(0,2,3,1)
        for sampleIdx, img in enumerate(permutedSample):
            img = (img + 1) / 2

            ax = axs[sampleIdx, col]
            ax.imshow(img.squeeze(), cmap="gray" if img.shape[-1]==1 else None)
            ax.axis("off")

    bigAx = fig.add_subplot(111, frameon=False)
    bigAx.set_xticks(np.arange(numCols))
    bigAx.set_yticks(np.arange(imgsPerSample))

    bigAx.set_xticklabels([f"{e}" for e in selectedEpochs])
    bigAx.set_yticklabels([f"{i}" for i in range(imgsPerSample)])

    bigAx.set_xlabel("Epoch")
    bigAx.set_ylabel("Latent Sample")
    bigAx.tick_params(labelcolor='black', top=False, bottom=False, left=False, right=False)

    fig.suptitle(title + f" Generated Images", fontsize=16)
    
    plt.tight_layout(rect=(0, 0, 1, 0.95))
    plt.show()

def visualiseVAELatentTraversal(vae: VAE, 
                             testDataloader: torch.utils.data.DataLoader, 
                             numSamples: int=5, 
                             latentIdx: int=0, 
                             steps: int=10, 
                             title: str="",
                             minZ: int=-3,
                             maxZ: int=3,
                             seed: int=42,
                             device: torch.device="cuda" if torch.cuda.is_available() else "cpu"):
    vae.eval()
    imgsToPlot = []
    labelsToPlot = []
    zVals = torch.linspace(start=minZ, end=maxZ, steps=steps)

    with torch.inference_mode():
        for xBatch, yBatch in testDataloader:
            xBatch = xBatch.to(device)
            for i in range(xBatch.size(0)):
                if len(imgsToPlot) == numSamples:
                    break
                x = xBatch[i].unsqueeze(0)
                y = yBatch[i].item()
                mu, logvar = vae.encode(x)
                
                torch.manual_seed(seed)
                z = vae.reparameterize(mu, logvar)

                travRow = []
                for val in zVals:
                    zdup = z.clone()
                    zdup[0, latentIdx] += val
                    xhat = vae.decode(zdup).squeeze(0).cpu()
                    xhat = (xhat + 1) / 2
                    xhat = xhat.permute(1, 2, 0).numpy()
                    travRow.append(xhat)
                
                imgsToPlot.append(travRow)
                labelsToPlot.append(testDataloader.dataset.classes[y])
            if len(imgsToPlot) == numSamples:
                break

    fig, axes = plt.subplots(nrows=numSamples, 
                            ncols=steps, 
                            figsize=(steps, numSamples))
    if numSamples == 1:
        axes = axes[np.newaxis, :]

    for row in range(numSamples):
        for col in range(steps):
            axes[row, col].imshow(imgsToPlot[row][col])
            axes[row, col].axis('off')
            if row == 0:
                axes[row, col].set_title(f"{zVals[col]:.2f}", fontsize=10)
            if col == 0:
                axes[row, col].set_title(labelsToPlot[row], loc='left', fontsize=10)

    fig.text(0.5, 0.04, 'Latent Value Offset', ha='center')
    plt.suptitle(f"{title} Latent space index: {latentIdx} Traversal")
    plt.tight_layout()
    plt.show()


    